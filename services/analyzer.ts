
import { ScheduleData, Metrics, CourseType, DaySchedule, CourseSession } from '../types';
import { DAYS_OF_WEEK, VI_DAYS_OF_WEEK } from '../constants';

export const calculateMetrics = (data: ScheduleData): Metrics => {
  let totalHours = 0;
  let totalSessions = 0;
  const hoursByDay: { [key: string]: number } = {};
  const hoursByWeek: { [key: number]: number } = {};
  const typeDistribution = { [CourseType.LT]: 0, [CourseType.TH]: 0 };
  const roomMetrics: { [key: string]: number } = {};
  const classMetrics: { [key: string]: number } = {};
  const coTeacherMap = new Map<string, { periods: number, subjects: Set<string> }>();
  
  const shiftStats = {
    morning: { hours: 0, sessions: 0 },
    afternoon: { hours: 0, sessions: 0 },
    evening: { hours: 0, sessions: 0 }
  };

  const warnings: string[] = [];
  
  // Normalize main teacher name for comparison
  const mainTeacherName = data.metadata.teacher.trim().toLowerCase();

  DAYS_OF_WEEK.forEach(d => hoursByDay[d] = 0);

  // Helper to check if session belongs to main teacher
  const isMainTeacher = (t: string) => {
    if (!t || t === "Chưa rõ" || t === "Unknown") return true;
    return t.toLowerCase().includes(mainTeacherName) || mainTeacherName.includes(t.toLowerCase());
  };

  // First pass: Detect Conflicts & Filter Co-teachers
  data.weeks.forEach(w => {
    Object.values(w.days).forEach(day => {
      const parts = day as DaySchedule;
      const allDaySessions = [...parts.morning, ...parts.afternoon, ...parts.evening];
      
      allDaySessions.forEach(s1 => {
        // Detect conflicts for all (just visual)
        const conflicts = allDaySessions.filter(s2 => 
          s1 !== s2 && 
          s1.teacher === s2.teacher && 
          s1.timeSlot === s2.timeSlot && 
          s1.room !== s2.room
        );
        if (conflicts.length > 0) {
          s1.hasConflict = true;
        }
      });
    });
  });

  let busiestWeek = { week: 1, hours: 0, range: '' };
  let peakWeekHeatmap: { day: string, count: number }[] = [];
  let peakWeekShiftStats = { morning: 0, afternoon: 0, evening: 0 };

  // Second pass: Calculate Metrics for Main Teacher ONLY
  data.weeks.forEach(w => {
    let weekTotal = 0;
    
    // Temp storage for peak week calculation
    const currentWeekHeatmap: Record<string, number> = {};
    DAYS_OF_WEEK.forEach(d => currentWeekHeatmap[d] = 0);
    const currentWeekShifts = { morning: 0, afternoon: 0, evening: 0 };

    Object.entries(w.days).forEach(([day, sessions]) => {
      const parts = sessions as DaySchedule;
      
      const processPart = (part: CourseSession[], shift: 'morning' | 'afternoon' | 'evening') => {
        part.forEach(s => {
          // If not main teacher, track co-teacher and skip main stats
          if (!isMainTeacher(s.teacher)) {
             if (!coTeacherMap.has(s.teacher)) {
                coTeacherMap.set(s.teacher, { periods: 0, subjects: new Set() });
             }
             const co = coTeacherMap.get(s.teacher)!;
             co.periods += s.periodCount;
             co.subjects.add(s.courseName);
             return;
          }

          // Main Teacher Stats
          shiftStats[shift].sessions += 1;
          shiftStats[shift].hours += s.periodCount;
          totalSessions += 1;
          
          typeDistribution[s.type] += s.periodCount;
          roomMetrics[s.room] = (roomMetrics[s.room] || 0) + s.periodCount;
          
          if (s.className) {
            classMetrics[s.className] = (classMetrics[s.className] || 0) + s.periodCount;
          }

          totalHours += s.periodCount;
          hoursByDay[day] += s.periodCount;
          weekTotal += s.periodCount;

          // For Peak Week Logic
          currentWeekHeatmap[day] += s.periodCount;
          currentWeekShifts[shift] += 1;

          // Warnings Check
          if (s.sessionTime === 'evening') warnings.push('EVENING_CLASS');
          if (['Saturday', 'Sunday'].includes(s.dayOfWeek)) warnings.push('WEEKEND_CLASS');
          if (s.periodCount === 1) warnings.push('SINGLE_PERIOD');
        });
      };

      processPart(parts.morning, 'morning');
      processPart(parts.afternoon, 'afternoon');
      processPart(parts.evening, 'evening');
    });

    hoursByWeek[w.weekNumber] = weekTotal;
    if (weekTotal > 25) warnings.push(`OVERLOAD_WEEK_${w.weekNumber}`);

    // Determine Peak Week
    if (weekTotal > busiestWeek.hours) {
      busiestWeek = { week: w.weekNumber, hours: weekTotal, range: w.dateRange };
      peakWeekHeatmap = Object.entries(currentWeekHeatmap).map(([d, c]) => ({ day: d, count: c }));
      peakWeekShiftStats = currentWeekShifts;
    }
  });

  let busiestDay = { day: 'Monday', hours: 0 };
  Object.entries(hoursByDay).forEach(([day, hours]) => {
    if (hours > busiestDay.hours) busiestDay = { day, hours };
  });

  const uniqueSubjects = new Set(data.allCourses.map(c => {
    const lastDot = c.code.lastIndexOf('.');
    return lastDot !== -1 ? c.code.substring(0, lastDot) : c.code;
  }));

  const topRooms = Object.entries(roomMetrics)
    .map(([room, periods]) => ({ room, periods }))
    .sort((a, b) => b.periods - a.periods)
    .slice(0, 10);

  const classDistribution = Object.entries(classMetrics)
    .map(([className, periods]) => ({ className, periods }))
    .sort((a, b) => b.periods - a.periods);

  const coTeachers = Array.from(coTeacherMap.entries()).map(([name, data]) => ({
    name,
    periods: data.periods,
    subjects: Array.from(data.subjects)
  }));

  // Process Warnings into unique strings
  const distinctWarnings: string[] = [];
  const overloadWeeks = warnings.filter(w => w.startsWith('OVERLOAD')).length;
  if (overloadWeeks > 0) distinctWarnings.push(`${overloadWeeks}/${data.weeks.length} tuần > 25 tiết (ngưỡng cảnh báo)`);
  
  const eveningCount = warnings.filter(w => w === 'EVENING_CLASS').length;
  if (eveningCount > 0) distinctWarnings.push(`${eveningCount} buổi dạy tối`);

  const weekendCount = warnings.filter(w => w === 'WEEKEND_CLASS').length;
  if (weekendCount > 0) distinctWarnings.push(`${weekendCount} buổi dạy cuối tuần (T7, CN)`);

  const singlePeriodCount = warnings.filter(w => w === 'SINGLE_PERIOD').length;
  if (singlePeriodCount > 0) distinctWarnings.push(`${singlePeriodCount} buổi chỉ có 1 tiết (hiệu suất thấp)`);

  // Generate Conclusions
  const conclusions: string[] = [];
  
  // 1. Time distribution
  const firstHalfWeeks = data.weeks.length / 2;
  const firstHalfHours = Object.entries(hoursByWeek).filter(([w]) => parseInt(w) <= firstHalfWeeks).reduce((acc, [, h]) => acc + h, 0);
  if (firstHalfHours > totalHours * 0.6) conclusions.push("Khối lượng tập trung đầu học kỳ");
  else if (firstHalfHours < totalHours * 0.4) conclusions.push("Khối lượng tập trung cuối học kỳ");
  else conclusions.push("Khối lượng phân bổ đều giữa học kỳ");

  // 2. Type
  if (typeDistribution[CourseType.TH] > typeDistribution[CourseType.LT]) 
    conclusions.push(`Thực hành chiếm ưu thế (${Math.round(typeDistribution[CourseType.TH]/totalHours*100)}%)`);
  else 
    conclusions.push(`Lý thuyết chiếm ưu thế (${Math.round(typeDistribution[CourseType.LT]/totalHours*100)}%)`);

  // 3. Peak time
  const maxShift = Object.entries(shiftStats).sort((a, b) => b[1].hours - a[1].hours)[0][0];
  const maxShiftVi = maxShift === 'morning' ? 'Sáng' : maxShift === 'afternoon' ? 'Chiều' : 'Tối';
  const busyDayVi = VI_DAYS_OF_WEEK[DAYS_OF_WEEK.indexOf(busiestDay.day)];
  conclusions.push(`${maxShiftVi} và ${busyDayVi} là thời gian cao điểm`);

  // 4. Efficiency
  if (singlePeriodCount > 0 || weekendCount > 0) conclusions.push("Có ca lẻ và dạy cuối tuần cần tối ưu");

  return {
    totalWeeks: data.weeks.length,
    totalHours,
    totalSessions,
    totalCourses: uniqueSubjects.size,
    totalGroups: data.allCourses.length,
    totalRooms: Object.keys(roomMetrics).length,
    busiestDay,
    busiestWeek,
    hoursByDay,
    hoursByWeek,
    typeDistribution,
    shiftStats,
    topRooms,
    classDistribution,
    coTeachers,
    warnings: distinctWarnings,
    conclusions,
    peakWeekHeatmap,
    peakWeekShiftStats
  };
};
